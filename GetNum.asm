; 206528275, 50%
; 315046128, 50%
.orig x41F4
GetNum:
ST R7, GETNUM_R7_SAVE
ST R0, GETNUM_R0_SAVE
ST R1, GETNUM_R1_SAVE ;IF POSITIVE NUMBER R1=0, IF NEGATIVE R1=1.
ST R4, GETNUM_R4_SAVE ; A HELPER REGISTER. WE WILL OVERWRIGHT IT'S VALUE OVER AND OVER
ST R3, GETNUM_R3_SAVE ; ANOTHER HELPER REGISTER, WE'LL USE FOR CONVENTION PREFERENCES. WE COULD'VE JUST USED AN ARRAY, BUT THIS WOULD BE EASIER FOR AN OUTSIDER TO UNDERSTAND THE CODE.
; Your code here. Remember to save the registers that you will use to subroutine-specific labels, and then load them just before the RET command.			
; Warning: GetNum can get SERIOUSLY LONG! Like, REALLY long. You may find yourself writing code so long it'll actually overflow into the address space of PrintNum! BE CAREFUL! Make sure to optimize the s*** out of this subroutine!
 LEA R0, START_MESSAGE ;PRINT THE START MESSAGE.
 PUTS 
 
	BEGINNING:
 AND R2, R2, #0
 AND R1, R1, #0 
 
 GETC         ;R0 HOLDS THE INPUT
 OUT          ;ECHO 

;CASE 1: CHECK IF THE FIRST INPUT IS "-" OR NEW LINE
 LD R3, MINUS_ASCII_SIGN
 ADD R4, R0, R3 ; CHECKING IF RO IS "-" SYMBOL
 BRz NEGATIVE_NUMBER 
 LD R3, NEW_LINE
 ADD R4, R0, R3   ;IF THE FIRST INPUT IS NEW LINE -> ILLEGAL 
 BRz PRINT_ERROR_MESSAGE
 
	GETNUM_LOOP: ;THIS LOOP WORKS AS LONG AS THE CHARACTERS WE'RE RECEIVING ARE LEGAL. 
 BR CHECK_CHARACTER
 CONTINUE1:   ;BACK FROM CHECK FUNCTION 
 BR UPDATE_R2
 CONTINUE2:   ;BACK FROM UPDATE FUNCTION///////////////////////////////////////////////////
 ;IF RECHED HERE, R2 IS UPDATED THE INPUT IS LEGAL SO FAR
 GETC 
 OUT
 LD R3, NEW_LINE
 ADD R4, R0, R3
 BRz FINISH ;IF R0=NEW LINE, FINISHED 
 BR GETNUM_LOOP 

	CHECK_CHARACTER: ;CHECKS IF THE CHAR IS>=48 OR <=57 WHIC IS THE RANGE OF LEGAL DIGITS.
 LD R3, LOWEST_NUMBER_ASCII
 ADD R4, R0, R3
 BRn ILLEGAL_CASE
 LD R3, HIGHEST_NUMBER_ASCII
 ADD R4, R0, R3
 BRp ILLEGAL_CASE
 BR CONTINUE1
 
 
	UPDATE_R2:
;CHECK IF NUM IS NEGATIVE OR POSITIVE.
 ADD R1, R1, #0
 BRp UPDATE_NEGATIVE ;IF R1=1, WE TREAT THE NUMBER AS NEGATIVE.
;NOW WE MULTIPLY THE CURRENT R2 VALUE WITH 10 AND ADD THE NUMBER VALUE IN R0.
;INSTEAD OF CALLING ANOTHER SABROUTINE, WE JUST ADD THE NUMBER 10 TIMES. THIS HELPS WITH CHECKING THE OVERFLOW :)
 LD R4, MUL_TIMES ;WE USE R4 AS A COUNTER FOR MULTIPLYING R2 
 AND R3, R3, #0
 MUL:
 ADD R3, R3, R2 ; R3 WILL HOLD THE RESULT OF MUL SINCE WE APPARENTLY HAVE OVERFLOW IF WE DO R2=R2+R2.
 BRn OVERFLOW_NUM ;IF THE SIGN OF R2 CHANGED IT MEANS OVERFLOW.
 ADD R4, R4, #-1 
 BRp MUL 
;CURRENT R3= THE R2*10 
 ADD R2, R3, #0 ; NOW CURRENT R2= PREVIOUS R2*10
 LD R3, LOWEST_NUMBER_ASCII
 ADD R4, R0, R3 ;UPDATE R4 TO THE DIGIT VALUE OF R0
 ADD R2, R2, R4 ;CURRENT R2= THE PREVIOUS R2*10 + NEW INPUT DIGIT  
 BRn OVERFLOW_NUM
 BR CONTINUE2
 
 ;WE CHOSE TO DEAL WITH NEGATIVE NUMBERS SEPARATELY BECAUSE OF THE OVERFLOW CASE. NUMBER OF NEGATIVE NUMBERS =NUMBER OF POSITIVE NUMBERS+1 THAT R2 CAN HOLD.
	UPDATE_NEGATIVE: ;WE DO THE SAME OPERATIONS WE DID IN UPDATE_R2 FUNCTION BUT WITH NEGATIVE NUMBERS
 LD R4, MUL_TIMES ;WE USE R4 AS A COUNTER FOR MULTIPLYING R2 
 AND R3, R3, #0
	MUL_NEGATIVE:
 ADD R3, R3, R2 
 BRp OVERFLOW_NUM ;IF THE SIGN OF R2 CHANGED IT MEANS OVERFLOW
 ADD R4, R4, #-1 
 BRp MUL_NEGATIVE 
;CURRENT R3= THE R2*10 
 ADD R2, R3, #0 ; NOW CURRENT R2= PREVIOUS R2*10
 LD R3, LOWEST_NUMBER_ASCII
 ADD R4, R0, R3 ;UPDATE R4 TO THE DIGIT VALUE OF R0
 NOT R4, R4      ;CONVERT THE DIGIT TO NEGATIVE
 ADD R4, R4, #1 
 ADD R2, R2, R4 ;CURRENT R2= THE PREVIOUS R2*10 + NEW INPUT DIGIT  
 BRp OVERFLOW_NUM
 BR CONTINUE2
 
 
 
 
 
	NEGATIVE_NUMBER: ;WE CHANGE R1=1 TO INDICATE THAT THE NUMBER IS NEGATIVE. 
 ADD R1, R1, #1
 GETC
 OUT 
;CHECK IF THE CHAR AFTER "-" IS A NEW LINE
 LD R3, NEW_LINE
 ADD R4, R0, R3
 BRz PRINT_ERROR_MESSAGE
 BR CHECK_CHARACTER ; IF REACHED HERE, THE CHAR IS NOT A NEW LINE, WE CHECK IF LEGAL  
 
 
	ILLEGAL_CASE: ;WE JUST KEEP ON RECEIVING THE INPUT AND PRINTING IT UNTIL NEW LINE, AND THEN PRINT THE ERROR MESSAGE.
 GETC
 OUT 
 LD R3, NEW_LINE
 ADD R4, R0, R3 
 BRnp ILLEGAL_CASE ;WE JUMP TO ILLEGAL_CASE LOOP UNTIL END OF INPUT.
 PRINT_ERROR_MESSAGE:
 LEA R0, ERROR_INPUT ;PRINT AN ERROR MESSAGE AND GO BACK TO BEGINNING
 PUTS 
 BR BEGINNING

	OVERFLOW_NUM:  ; WE SHOULD CHECK IF ILLEGAL EVEN WHEN OVERFLOW
 GETC
 OUT 
 LD R3, NEW_LINE ;IF R0=NEW LINE, PRINT THE SUITABLE MESSAGE
 ADD R4, R0, R3
 BRz PRINT_OVERFLOW_MESSAGE
;CHECK IF ILLEGAL NUMBER EVEN WHEN IT'S ALREADY OVERFLOW 
 LD R3, LOWEST_NUMBER_ASCII
 ADD R4, R0, R3
 BRn ILLEGAL_CASE
 LD R3, HIGHEST_NUMBER_ASCII
 ADD R4, R0, R3
 BRp ILLEGAL_CASE
; IF THE CHAR ISN'T A NEW LINE NOR IS IT ILLEGAL, JUMP BACK TO THE LOOP TO FINISH RECEIVING THE INPUT.
 BR OVERFLOW_NUM 
 PRINT_OVERFLOW_MESSAGE:
 LEA R0, OVERFLOW_MESSAGE ;PRINT AN OVERFLOW MESSAGE AND GO BACK TO BEGINNING//////////////
 PUTS 
 BR BEGINNING

	FINISH: 
LD R7, GETNUM_R7_SAVE
LD R0, GETNUM_R0_SAVE
LD R1, GETNUM_R1_SAVE
LD R3, GETNUM_R3_SAVE
LD R4, GETNUM_R4_SAVE

ret

GETNUM_R7_SAVE .fill #0
GETNUM_R0_SAVE .fill #0 
GETNUM_R1_SAVE .fill #0 
GETNUM_R3_SAVE .fill #0 
GETNUM_R4_SAVE .fill #0

MINUS_ASCII_SIGN     .fill #-45 
LOWEST_NUMBER_ASCII  .fill #-48 
HIGHEST_NUMBER_ASCII .fill #-57
NEW_LINE             .fill #-10
MUL_TIMES            .fill #10

START_MESSAGE    .stringz "Enter an integer number: "
ERROR_INPUT      .stringz "Error! You did not enter a number. Please enter again: "
OVERFLOW_MESSAGE .stringz "Error! Number overflowed! Please enter again: "
; Put your various labels here, between RET and .END.
; Remember to write comments that thoroughly explain everything you do - this is assembly code, not Python or C! It's hard to follow otherwise.	

; Make sure to properly write your real ID at the top of this asm file, don't just leave the default values there!


; By the way, no one says you can't actually write several helper subroutines in this very file, you know? Like a subroutine to check the validity of an input character, or a subroutine that actually takes care of updating the number you're creating with the ongoing input...

; Here's a challenge for you - make GetNum work WITHOUT an array to keep (even just temporarily) the various characters you input. Can you handle it? Who knows, there might be a bonus if you can do it ;)
.end
